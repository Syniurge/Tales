# - Find flexc++ executable and provides a macro to generate custom build rules
#
# The module defines the following variables:
#  FLEXCPP_FOUND - true is flexc++ executable is found
#  FLEXCPP_EXECUTABLE - the path to the flexc++ executable
#  FLEXCPP_VERSION - the version of flexc++
#  FLEXCPP_LIBRARIES - The flexc++ libraries
#  FLEXCPP_INCLUDE_DIRS - The path to the flexc++ headers
#
# The minimum required version of flexc++ can be specified using the
# standard syntax, e.g. FIND_PACKAGE(FLEXCPP 2.5.13)
#
#
# If flexc++ is found on the system, the module provides the macro:
#  FLEXCPP_TARGET(Name FlexInput FlexOutput [COMPILE_FLAGS <string>])
# which creates a custom command  to generate the <FlexOutput> file from
# the <FlexInput> file.  If  COMPILE_FLAGS option is specified, the next
# parameter is added to the flexc++  command line. Name is an alias used to
# get  details of  this custom  command.  Indeed the  macro defines  the
# following variables:
#  FLEXCPP_${Name}_DEFINED - true is the macro ran successfully
#  FLEXCPP_${Name}_OUTPUTS - the source file generated by the custom rule, an
#  alias for FlexOutput
#  FLEXCPP_${Name}_INPUT - the flexc++ source file, an alias for ${FlexInput}
#
# Flex scanners oftenly use tokens  defined by Bison: the code generated
# by Flex  depends of the header  generated by Bison.   This module also
# defines a macro:
#  ADD_FLEXCPP_BISONCPP_DEPENDENCY(FlexTarget BisonTarget)
# which  adds the  required dependency  between a  scanner and  a parser
# where  <FlexTarget>  and <BisonTarget>  are  the  first parameters  of
# respectively FLEXCPP_TARGET and BISONCPP_TARGET macros.
#
#  ====================================================================
#  Example:
#
#   find_package(BISONCPP)
#   find_package(FLEXCPP)
#
#   BISONCPP_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
#   FLEXCPP_TARGET(MyScanner lexer.l  ${CMAKE_CURRENT_BINARY_DIR}/lexer.cpp)
#   ADD_FLEXCPP_BISONCPP_DEPENDENCY(MyScanner MyParser)
#
#   include_directories(${CMAKE_CURRENT_BINARY_DIR})
#   add_executable(Foo
#      Foo.cc
#      ${BISONCPP_MyParser_OUTPUTS}
#      ${FLEXCPP_MyScanner_OUTPUTS}
#   )
#  ====================================================================

#=============================================================================
# Copyright 2013 Elie Morisse
# Copyright 2009 Kitware, Inc.
# Copyright 2006 Tristan Carel
#
# Distributed under the OSI-approved BSD License (the "License");
# see accompanying file Copyright.txt for details.
#
# This software is distributed WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the License for more information.
#=============================================================================
# (To distribute this file outside of CMake, substitute the full
#  License text for the above reference.)

FIND_PROGRAM(FLEXCPP_EXECUTABLE flexc++ DOC "path to the flexc++ executable")
MARK_AS_ADVANCED(FLEXCPP_EXECUTABLE)

FIND_LIBRARY(FL_LIBRARY NAMES fl
  DOC "Path to the fl library")

FIND_PATH(FLEXCPP_INCLUDE_DIR FlexLexer.h
  DOC "Path to the flexc++ headers")

MARK_AS_ADVANCED(FL_LIBRARY FLEXCPP_INCLUDE_DIR)

SET(FLEXCPP_INCLUDE_DIRS ${FLEXCPP_INCLUDE_DIR})
SET(FLEXCPP_LIBRARIES ${FL_LIBRARY})

IF(FLEXCPP_EXECUTABLE)

  EXECUTE_PROCESS(COMMAND ${FLEXCPP_EXECUTABLE} --version 
    OUTPUT_VARIABLE FLEXCPP_version_output
    ERROR_VARIABLE FLEXCPP_version_error
    RESULT_VARIABLE FLEXCPP_version_result
    OUTPUT_STRIP_TRAILING_WHITESPACE)

  IF(NOT ${FLEXCPP_version_result} EQUAL 0) # NOTE: flexc++ used to return 1 insead of 0
    IF(FLEXCPP_FIND_REQUIRED)
      MESSAGE(SEND_ERROR "Command \"${FLEXCPP_EXECUTABLE} --version\" failed with output:\n${FLEXCPP_version_output}\n${FLEXCPP_version_error}")
    ELSE()
      MESSAGE("Command \"${FLEXCPP_EXECUTABLE} --version\" failed with output:\n${FLEXCPP_version_output}\n${FLEXCPP_version_error}\nFLEXCPP_VERSION will not be available")
    ENDIF()
  ELSE()
    STRING(REGEX REPLACE "^flexc\\+\\+ V([0-9]+[^ ]*)$" "\\1"
      FLEXCPP_VERSION "${FLEXCPP_version_output}")
  ENDIF()

  # internal macro
  MACRO(FLEXCPP_TARGET_option_extraopts Options)
    SET(FLEXCPP_TARGET_extraopts "${Options}")
    SEPARATE_ARGUMENTS(FLEXCPP_TARGET_extraopts)
    LIST(APPEND FLEXCPP_EXECUTABLE_opts ${FLEXCPP_TARGET_extraopts})
  ENDMACRO(FLEXCPP_TARGET_option_extraopts)

  #============================================================
  # FLEXCPP_TARGET (public macro)
  #============================================================
  #
  MACRO(FLEXCPP_TARGET Name Input Output)
    SET(FLEXCPP_TARGET_usage "FLEXCPP_TARGET(<Name> <Input> <Output> [DEBUG] [IMPLEMENTATION_HEADERS <extensionless file>] [COMPILE_FLAGS <string>]")

    STRING(REGEX REPLACE "\\.[a-zA-Z0-9_]+$" "base.h" FLEXCPP_TARGET_baseclassh "${Output}")
    LIST(APPEND FLEXCPP_TARGET_extraoutputs "${FLEXCPP_TARGET_baseclassh}")
    LIST(APPEND FLEXCPP_EXECUTABLE_opts -b "${FLEXCPP_TARGET_baseclassh}")

    SET(FLEXCPP_parse_options DEBUG)
    SET(FLEXCPP_parse_onevalue IMPLEMENTATION_HEADERS)
    SET(FLEXCPP_parse_multivalues COMPILE_FLAGS)
    CMAKE_PARSE_ARGUMENTS(FLEXCPP "${FLEXCPP_parse_options}" "${FLEXCPP_parse_onevalue}" "${FLEXCPP_parse_multivalues}" ${ARGN})

    IF("${FLEXCPP_UNPARSED_ARGUMENTS}")
      MESSAGE(SEND_ERROR ${FLEXCPP_TARGET_usage})
    ELSE()
      IF("${FLEXCPP_DEBUG}")
        LIST(APPEND FLEXCPP_EXECUTABLE_opts --debug)
      ENDIF()

      IF("${FLEXCPP_IMPLEMENTATION_HEADERS}")
        FLEXCPP_TARGET_option_extraopts("-c \"${FLEXCPP_IMPLEMENTATION_HEADERS}.h\" -i \"${FLEXCPP_IMPLEMENTATION_HEADERS}.ih\"")
      ENDIF()

      IF("${FLEXCPP_COMPILE_FLAGS}")
        LIST(APPEND FLEXCPP_EXECUTABLE_opts ${FLEXCPP_COMPILE_FLAGS})
      ENDIF()

      ADD_CUSTOM_COMMAND(OUTPUT ${Output} ${FLEXCPP_TARGET_extraoutputs}
        COMMAND ${FLEXCPP_EXECUTABLE}
        ARGS ${FLEXCPP_EXECUTABLE_opts} -l ${Output} ${Input}
        DEPENDS ${Input}
        COMMENT "[FLEXCPP][${Name}] Building scanner with flexc++ ${FLEXCPP_VERSION}"
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})

      SET(FLEXCPP_${Name}_DEFINED TRUE)
      SET(FLEXCPP_${Name}_OUTPUTS ${Output})
      SET(FLEXCPP_${Name}_INPUT ${Input})
      SET(FLEXCPP_${Name}_COMPILE_FLAGS ${FLEXCPP_EXECUTABLE_opts})
    ENDIF()
  ENDMACRO(FLEXCPP_TARGET)
  #============================================================


  #============================================================
  # ADD_FLEXCPP_BISONCPP_DEPENDENCY (public macro)
  #============================================================
  #
  MACRO(ADD_FLEXCPP_BISONCPP_DEPENDENCY FlexTarget BisonTarget)

    IF(NOT FLEXCPP_${FlexTarget}_OUTPUTS)
      MESSAGE(SEND_ERROR "Flex target `${FlexTarget}' does not exists.")
    ENDIF()

    IF(NOT BISONCPP_${BisonTarget}_OUTPUTS)
      MESSAGE(SEND_ERROR "Bison target `${BisonTarget}' does not exists.")
    ENDIF()

    SET_SOURCE_FILES_PROPERTIES(${FLEXCPP_${FlexTarget}_OUTPUTS}
      PROPERTIES OBJECT_DEPENDS ${BISONCPP_${BisonTarget}_OUTPUTS})
  ENDMACRO(ADD_FLEXCPP_BISONCPP_DEPENDENCY)
  #============================================================

ENDIF(FLEXCPP_EXECUTABLE)

INCLUDE(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(FLEXCPP REQUIRED_VARS FLEXCPP_EXECUTABLE
                                       VERSION_VAR FLEXCPP_VERSION)

# FindFLEXCPP.cmake ends here
