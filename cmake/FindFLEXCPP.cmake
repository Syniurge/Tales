# - Find flexc++ executable and provides a macro to generate custom build rules
#
# The module defines the following variables:
#  FLEXCPP_FOUND - true is flexc++ executable is found
#  FLEXCPP_EXECUTABLE - the path to the flexc++ executable
#  FLEXCPP_VERSION - the version of flexc++
#  FLEXCPP_LIBRARIES - The flexc++ libraries
#  FLEXCPP_INCLUDE_DIRS - The path to the flexc++ headers
#
# The minimum required version of flexc++ can be specified using the
# standard syntax, e.g. FIND_PACKAGE(FLEXCPP 2.5.13)
#
#
# If flexc++ is found on the system, the module provides the macro:
#  FLEXCPP_TARGET(Name FlexInput FlexOutput [COMPILE_FLAGS <string>])
# which creates a custom command  to generate the <FlexOutput> file from
# the <FlexInput> file.  If  COMPILE_FLAGS option is specified, the next
# parameter is added to the flexc++  command line. Name is an alias used to
# get  details of  this custom  command.  Indeed the  macro defines  the
# following variables:
#  FLEXCPP_${Name}_DEFINED - true is the macro ran successfully
#  FLEXCPP_${Name}_OUTPUTS - the source file generated by the custom rule, an
#  alias for FlexOutput
#  FLEXCPP_${Name}_INPUT - the flexc++ source file, an alias for ${FlexInput}
#
# Flex scanners oftenly use tokens  defined by Bison: the code generated
# by Flex  depends of the header  generated by Bison.   This module also
# defines a macro:
#  ADD_FLEXCPP_BISONCPP_DEPENDENCY(FlexTarget BisonTarget)
# which  adds the  required dependency  between a  scanner and  a parser
# where  <FlexTarget>  and <BisonTarget>  are  the  first parameters  of
# respectively FLEXCPP_TARGET and BISONCPP_TARGET macros.
#
#  ====================================================================
#  Example:
#
#   find_package(BISONCPP)
#   find_package(FLEXCPP)
#
#   BISONCPP_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
#   FLEXCPP_TARGET(MyScanner lexer.l  ${CMAKE_CURRENT_BINARY_DIR}/lexer.cpp)
#   ADD_FLEXCPP_BISONCPP_DEPENDENCY(MyScanner MyParser)
#
#   include_directories(${CMAKE_CURRENT_BINARY_DIR})
#   add_executable(Foo
#      Foo.cc
#      ${BISONCPP_MyParser_OUTPUTS}
#      ${FLEXCPP_MyScanner_OUTPUTS}
#   )
#  ====================================================================

#=============================================================================
# Copyright 2013 Elie Morisse
# Copyright 2009 Kitware, Inc.
# Copyright 2006 Tristan Carel
#
# Distributed under the OSI-approved BSD License (the "License");
# see accompanying file Copyright.txt for details.
#
# This software is distributed WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the License for more information.
#=============================================================================
# (To distribute this file outside of CMake, substitute the full
#  License text for the above reference.)

FIND_PROGRAM(FLEXCPP_EXECUTABLE flexc++ DOC "path to the flexc++ executable")
MARK_AS_ADVANCED(FLEXCPP_EXECUTABLE)

FIND_LIBRARY(FL_LIBRARY NAMES fl
	DOC "Path to the fl library")

FIND_PATH(FLEXCPP_INCLUDE_DIR FlexLexer.h
	DOC "Path to the flexc++ headers")

MARK_AS_ADVANCED(FL_LIBRARY FLEXCPP_INCLUDE_DIR)

SET(FLEXCPP_INCLUDE_DIRS ${FLEXCPP_INCLUDE_DIR})
SET(FLEXCPP_LIBRARIES ${FL_LIBRARY})

IF(FLEXCPP_EXECUTABLE)
	EXECUTE_PROCESS(COMMAND ${FLEXCPP_EXECUTABLE} --version
		OUTPUT_VARIABLE FLEXCPP_version_output
		ERROR_VARIABLE FLEXCPP_version_error
		RESULT_VARIABLE FLEXCPP_version_result
		OUTPUT_STRIP_TRAILING_WHITESPACE)

	IF(NOT ${FLEXCPP_version_result} EQUAL 0) # NOTE: flexc++ used to return 1 insead of 0
		IF(FLEXCPP_FIND_REQUIRED)
			MESSAGE(SEND_ERROR "Command \"${FLEXCPP_EXECUTABLE} --version\" failed with output:\n${FLEXCPP_version_output}\n${FLEXCPP_version_error}")
		ELSE()
			MESSAGE("Command \"${FLEXCPP_EXECUTABLE} --version\" failed with output:\n${FLEXCPP_version_output}\n${FLEXCPP_version_error}\nFLEXCPP_VERSION will not be available")
		ENDIF()
	ELSE()
		STRING(REGEX REPLACE "^flexc\\+\\+ V([0-9]+[^ ]*)$" "\\1"
			FLEXCPP_VERSION "${FLEXCPP_version_output}")
	ENDIF()

	INCLUDE(FLEXCPP)
ENDIF(FLEXCPP_EXECUTABLE)

INCLUDE(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(FLEXCPP REQUIRED_VARS FLEXCPP_EXECUTABLE
		VERSION_VAR FLEXCPP_VERSION)

# FindFLEXCPP.cmake ends here
